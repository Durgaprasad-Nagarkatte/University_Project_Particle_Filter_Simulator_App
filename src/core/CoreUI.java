package core;

import java.math.BigDecimal;
import java.util.*;
import java.util.Map.Entry;

import processing.core.*;

public class CoreUI extends PApplet {

	// Create default variables
	List<Landmark> landmarks = new ArrayList<>();
	final double WORLD_SIZE = 100.0;
	int maxParticles = 1000;
	Robot robot;
	Random rand = new Random();
	int frameCounter = 0;

	double FORWARD_NOISE = 0.05;
	double TURN_NOISE = 0.05;
	double SENSOR_NOISE = 5.0;

	// Collections to hold the particles and the readings generated by the robot
	List<Double> sensorReadings;
	List<Particle> particlesList;

	// user interface variables
	int Yellow = color(255, 255, 0);
	int Red = color(255, 0, 0);
	int Green = color(0, 255, 0);
	int Blue = color(0, 0, 255);
	int White = color(255);
	int Black = color(0);

	public void settings() {
		size(1400, 1000);
		noSmooth();
	}

	public void setup() {
		
		background(0);

		// setup the landmarks in the world
		landmarks.add(new Landmark(this, 20.0, 20.0));
		landmarks.add(new Landmark(this, 80.0, 80.0));
		landmarks.add(new Landmark(this, 20.0, 80.0));
		landmarks.add(new Landmark(this, 80.0, 20.0));

		// create robot - give map of world
		robot = new Robot(this, WORLD_SIZE, landmarks);

		particlesList = genParticles(maxParticles, WORLD_SIZE, landmarks, FORWARD_NOISE, TURN_NOISE, SENSOR_NOISE);
		

	}

	
	public void draw() {
		
		background(255);
		
		fill(153);
		rect(1000, 0, 400, 1000);
		
		translate(0, height);
		scale(1, -1);

		// draw landmarks
		for (Landmark currLandmark : landmarks) {
			currLandmark.draw();
		}

		// draw particles
		for (Particle par : particlesList) {
			par.draw();
		}
		
		// draw robot
		robot.draw();
		
		if (frameCounter > 4) {
		
		// update the position of the robot and the particles
		robot = robot.move(0.1, 5);
		particlesList = moveParticles(particlesList, 0.1, 5);

		sensorReadings = robot.sense();
		particlesList = weighParticles(particlesList, sensorReadings);
		
		particlesList = resampleParticlesBigDecimal(particlesList);
		}
		
		frameCounter++;
		
		delay(100);
	}

	/**
	 * Create string representation of the distances to the landmarks
	 * 
	 * @param readings
	 *            the list of readings to turn into a string
	 * @return
	 */
	public String readingsToString(List<Double> readings) {

		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.append('[');

		for (Iterator<Double> readingItr = readings.iterator(); readingItr.hasNext();) {

			double val = readingItr.next().doubleValue();
			stringBuilder.append(String.format("%.3f", val));

			if (readingItr.hasNext()) {
				stringBuilder.append(", ");
			} else {
				stringBuilder.append(']');
			}
		}
		return stringBuilder.toString();
	}

	/**
	 * Generate a random distribution of particles
	 * 
	 * @param numParticles
	 *            number of particles the distribution will have
	 * @param worldSize
	 *            the size of the world the particles will be placed in
	 * @param landmarks
	 *            landmarks that are in the world
	 * @return
	 */
	public List<Particle> genParticles(final int numParticles, double worldSize, List<Landmark> landmarks,
			double forwardNoise, double turnNoise, double sensorNoise) {

		List<Particle> genParticles = new ArrayList<>(numParticles);

		for (int i = 0; i < numParticles; i++) {
			Particle tempParticle = new Particle(this, worldSize, landmarks);
			tempParticle.setNoise(forwardNoise, turnNoise, sensorNoise);
			genParticles.add(tempParticle);
		}
		return genParticles;
	}

	/**
	 * Move a given distribution of particles by the provided parameters
	 * 
	 * @param originParticles
	 *            the set of particles to move
	 * @param turn
	 *            how much heading of each particle will change by
	 * @param forward
	 *            how much forward motion will each particle make
	 * @return a new distributions of particles that have been move using the
	 *         parameters
	 */
	public List<Particle> moveParticles(List<Particle> originParticles, double turn, double forward) {

		List<Particle> newParticles = new ArrayList<>(originParticles.size());

		for (Particle currParticle : originParticles) {
			newParticles.add(new Particle(currParticle.move(turn, forward)));
		}

		return newParticles;
	}

	public List<Particle> weighParticles(List<Particle> originParticles, List<Double> measurementVec) {

		List<Particle> weightedParticles = new ArrayList<>(originParticles.size());
		double weightSum = 0.0;

		// loop through each particle and calculate how plausible position is
		// given measurementVec
		for (Particle currParticle : originParticles) {

			double particleWeight = currParticle.measurementProb(measurementVec);
			weightSum += particleWeight;

			currParticle.setWeight(particleWeight);
			weightedParticles.add(currParticle);
		}

		// use the sum of the particle weights to give each particle a
		// normalised weight
		for (Particle currParticle : weightedParticles) {

			double normWeight = currParticle.getWeight() / weightSum;
			currParticle.setNormalisedWeight(normWeight);
		}

		return weightedParticles;
	}

	
	public List<Particle> resampleParticlesBigDecimal(List<Particle> originParticles) {

		// map the particles to a finite range less than 1 that defines
		// how likely they are to be correct, re-sample based on this map
		NavigableMap<BigDecimal, Particle> probMap = new TreeMap<>();
		final int ORIGIN_SIZE = originParticles.size();

		// accumulate the probability of each particle into probabilitySum and
		// use it to give each particle a slice of the values from 0 - 1
		BigDecimal probSum = new BigDecimal(0.0);
		for (Particle currParticle : originParticles) {

			// BigDecimal used for arbitrary precision arithmetic
			BigDecimal currentProb = new BigDecimal(currParticle.getNormalisedWeight());
			probSum = probSum.add(currentProb);
			probMap.put(probSum, currParticle);
		}

		// create a new empty list of particles to store the new samples
		List<Particle> newParticles = new ArrayList<>(ORIGIN_SIZE);

		// Loop through the probMap and randomly generate N keys to pick out
		// N new particles for the re-sample, the probability of a particle
		// being picked depends on the plausibility of the particles measurement
		// vector
		for (int i = 0; i < ORIGIN_SIZE; i++) {

			// use random num between [0 : 1) to choose particle
			BigDecimal randVal = new BigDecimal(rand.nextDouble());
			Particle pickedParticle = probMap.get(probMap.ceilingKey(randVal));

			// NOTE: we use the copy constructor here as each particle must be a
			// new distinct particle with its own allocated memory & attributes
			newParticles.add(new Particle(pickedParticle));
		}

		return newParticles;
	}
	
	public List<Particle> resampleParticlesDouble(List<Particle> originParticles) {

		// map the particles to a finite range less than 1 that defines
		// how likely they are to be correct, re-sample based on this map
		NavigableMap<Double, Particle> probMap = new TreeMap<>();
		final int ORIGIN_SIZE = originParticles.size();

		// accumulate the probability of each particle into probabilitySum and
		// use it to give each particle a slice of the values from 0 - 1
		Double probSum = 0.0;
		for (Particle currParticle : originParticles) {

			// BigDecimal used for arbitrary precision arithmetic
			Double currentProb = currParticle.getNormalisedWeight();
			probSum += currentProb;
			probMap.put(probSum, currParticle);
		}

		// create a new empty list of particles to store the new samples
		List<Particle> newParticles = new ArrayList<>(ORIGIN_SIZE);

		// Loop through the probMap and randomly generate N keys to pick out
		// N new particles for the re-sample, the probability of a particle
		// being picked depends on the plausibility of the particles measurement
		// vector
		for (int i = 0; i < ORIGIN_SIZE; i++) {

			// use random num between [0 : 1) to choose particle
			Double randVal = rand.nextDouble();
			Particle pickedParticle = probMap.get(probMap.ceilingKey(randVal));

			// NOTE: we use the copy constructor here as each particle must be a
			// new distinct particle with its own allocated memory & attributes
			newParticles.add(new Particle(pickedParticle));
		}

		return newParticles;
	}
	
	public void printParticleDistributionCount (List<Particle> particles) {
		
		// create a map that counts each particles occurrence in the re-sample
		NavigableMap<String, Integer> map = new TreeMap<>();
		for (Particle par : particles) {
			
			String posStr = String.format("X: %.3f Y: %.3f", par.getX(), par.getY());
			int val;
			if (map.containsKey(posStr)) {
				val = map.get(posStr);
				val++;
				map.put(posStr, val);
			}
			else {
				map.put(posStr, 1);
			}
		}
		
		int total = 0;
		for (Entry<String, Integer> entry : map.entrySet()) {
			String key = entry.getKey();
		    Integer value = entry.getValue();
		    total += value;
		    System.out.println("Pos: " + key + "   Count:" + value);
		}
		
		System.out.println("Total count:" + total);
	}

	/**
	 * Convert degrees to radians, (short hand wrapper method)
	 * 
	 * @param degrees
	 *            degrees value to convert
	 * @return converted value in radians
	 */
	public double d2r(double degrees) {
		return Math.toRadians(degrees);
	}

}
