package core;

import java.math.BigDecimal;
import java.util.*;
import java.util.Map.Entry;

import map.Landmark;
import processing.core.*;
import robot.Particle;
import robot.Robot;
import util.UtilParticle;

public class CoreUI extends PApplet {

	// Create default variables
	List<Landmark> landmarks = new ArrayList<>();
	final double WORLD_SIZE_WIDTH 	= 100.0;
	final double WORLD_SIZE_HEIGHT 	= 76.8;
	double Sensor_Range = 50;
	int maxParticles = 1000;
	Robot robot;
	Random rand = new Random();
	int frameCounter = 0;

	double FORWARD_NOISE = 0.05;
	double TURN_NOISE = 0.05;
	double SENSOR_NOISE = 5.0;

	// Collections to hold the particles and the readings generated by the robot
	NavigableMap<Integer, Double> sensorReadings;
	List<Particle> particlesList;

	// user interface variables
	int Yellow = color(255, 255, 0);
	int Red = color(255, 0, 0);
	int Green = color(0, 255, 0);
	int Blue = color(0, 0, 255);
	int White = color(255);
	int Black = color(0);

	public void settings() {
		
		// Set for laptop screen size
		size(1366, 768);
		noSmooth();
	}

	public void setup() {
		
		background(0);

		// setup the landmarks in the world
		landmarks.add(new Landmark(this, 20.0, 20.0));
		landmarks.add(new Landmark(this, 60.0, 60.0));
		landmarks.add(new Landmark(this, 20.0, 60.0));
		landmarks.add(new Landmark(this, 60.0, 20.0));

		// create robot - give map of world
		robot = new Robot(this, WORLD_SIZE_WIDTH, WORLD_SIZE_HEIGHT, landmarks, Sensor_Range);

		particlesList = UtilParticle.genParticles(this, maxParticles, WORLD_SIZE_WIDTH, WORLD_SIZE_HEIGHT, landmarks, Sensor_Range, FORWARD_NOISE, TURN_NOISE, SENSOR_NOISE);
		

	}

	
	public void draw() {
		
		background(240);
		
		// flip and translate the axis to make plotting like a normal graph
		translate(0, height);
		scale(1, -1);

		// draw landmarks
		for (Landmark currLandmark : landmarks) {
			currLandmark.draw();
		}

		// draw particles
		for (Particle par : particlesList) {
			par.draw();
		}
		
		// draw robot
		robot.draw();
		
		// Draw area for control panel
		fill(153);
		rect(1000, 0, 366, height);
		
		if (frameCounter > 5) {
		
			// update the position of the robot and the particles
			robot = robot.move(0.1, 5);
			particlesList = UtilParticle.moveParticles(particlesList, 0.1, 5);
	
			sensorReadings = robot.sense();
			particlesList = UtilParticle.weighParticles(particlesList, sensorReadings);
			
			particlesList = UtilParticle.resampleParticlesBigDecimal(particlesList);
		}
		
		frameCounter++;
		
		delay(100);
	}

	


	/**
	 * Convert degrees to radians, (short hand wrapper method)
	 * 
	 * @param degrees
	 *            degrees value to convert
	 * @return converted value in radians
	 */
	public double d2r(double degrees) {
		return Math.toRadians(degrees);
	}

}
