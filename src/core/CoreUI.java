package core;

import java.math.BigDecimal;
import java.util.*;
import java.util.Map.Entry;

import controlP5.Button;
import controlP5.CallbackEvent;
import controlP5.CallbackListener;
import controlP5.ControlP5;
import map.Landmark;
import processing.core.*;
import robot.Particle;
import robot.Robot;
import util.UtilParticle;

public class CoreUI extends PApplet {

	// Create default variables
	List<Landmark> landmarks = new ArrayList<>();
	final double WORLD_SIZE_WIDTH 	= 100.0;
	final double WORLD_SIZE_HEIGHT 	= 76.8;
	double Sensor_Range = 50;
	int Max_Particles = 1000;
	Robot robot;
	Random rand = new Random();

	double FORWARD_NOISE = 0.05;
	double TURN_NOISE = 0.05;
	double SENSOR_NOISE = 5.0;
	
	// Signal variables
	boolean IS_SIM_RUNNING = false;
	boolean ADDING_LANDMARKS_MODE = false;

	// Collections to hold the particles and the readings generated by the robot
	NavigableMap<Integer, Double> sensorReadings;
	List<Particle> particlesList;

	// user interface variables
	int Yellow = color(255, 255, 0);
	int Red = color(255, 0, 0);
	int Green = color(0, 255, 0);
	int Blue = color(0, 0, 255);
	int White = color(255);
	int Black = color(0);
	
	int DefaultBlue = color(0, 45, 90);
	int ActiveGreen = color(0, 204, 102);

	public void settings() {
		
		// Set for laptop screen size
		size(1366, 768);
		smooth();
	}

	public void setup() {
		
		background(0);

		// create robot - give it information about the world
		robot = new Robot(this, WORLD_SIZE_WIDTH, WORLD_SIZE_HEIGHT, landmarks, Sensor_Range);

		particlesList = UtilParticle.genParticles(this, Max_Particles, WORLD_SIZE_WIDTH, WORLD_SIZE_HEIGHT, landmarks, Sensor_Range, FORWARD_NOISE, TURN_NOISE, SENSOR_NOISE);
		
		setupUserInterface();
		setupListeners();
	}

	
	public void draw() {
		
		background(240);
		
		
		// draw landmarks
		for (Landmark currLandmark : landmarks) {
			currLandmark.draw();
		}

		// draw particles
		for (Particle par : particlesList) {
			par.draw();
		}
		
		// draw robot
		robot.draw();
		
		// Draw area for control panel
		fill(153);
		rect(1000, 0, 366, height);
		
		// only begin operation once the settings are in place
		if (true == IS_SIM_RUNNING) {
			
			// update the position of the robot and the particles
			robot = robot.move(0.1, 5);
			particlesList = UtilParticle.moveParticles(particlesList, 0.1, 5);
	
			sensorReadings = robot.sense();
			particlesList = UtilParticle.weighParticles(particlesList, sensorReadings);
			
			particlesList = UtilParticle.resampleParticlesBigDecimal(particlesList);
		}
		
		delay(100);
	}

	
	public void mousePressed() {
		
		
		
		// when in this mode we are adding landmarks
		if (true == ADDING_LANDMARKS_MODE) {
			
			final double xPosLandmark = mouseX / 10.0;
			final double yPosLandmark = (height-mouseY) / 10.0;
			
			// make sure selected position is in the drawn world (not near buttons)
			if (xPosLandmark <= WORLD_SIZE_WIDTH && yPosLandmark <= WORLD_SIZE_HEIGHT) {
				landmarks.add(new Landmark(this, xPosLandmark, yPosLandmark));
			}
		}
		
	}
	public void setupUserInterface() {
		
		cp5 = new ControlP5(this);
		ArialFont16 = createFont("arial", 16, true);
		ArialFont14 = createFont("arial", 14, true);
		
		final int spaceDssplayAndEnd = 366;
		final int standardFieldHeight = 32;
		final int standardFieldWidth = (spaceDssplayAndEnd / 3) * 2;
		final int standardLabelTextSize = 12;
		final int standardHeightDivisor = 24;
		final int standardXPos = 1000 + (spaceDssplayAndEnd / 6);
		
		
		/* add landmarks button --------------------------------------------------------- */
		final int landmarksButtonY = (height / standardHeightDivisor) * 1;
		landmarksButton = cp5.addButton("landmarksButton")
							 .setPosition(standardXPos, landmarksButtonY)
							 .setSize(standardFieldWidth, standardFieldHeight)
							 .setCaptionLabel("Add Landmarks");
		
		landmarksButton.getCaptionLabel()
		  		 	   .setSize(standardLabelTextSize);
		
		landmarksButton.setColorBackground(DefaultBlue);
		
		/* run button ------------------------------------------------------------------ */
		final int runButtonY = (height / standardHeightDivisor) * 21;
		runButton = cp5.addButton("runButton")
							 .setPosition(standardXPos, runButtonY)
							 .setSize(standardFieldWidth, standardFieldHeight)
							 .setCaptionLabel("Run");
		
		runButton.getCaptionLabel()
		  		 	   .setSize(standardLabelTextSize);
		
		
		
	}
	
	public void setupListeners () {
		
		/* add landmarks button functionality ------------------------------------------ */
		landmarksButton.onClick(new CallbackListener() {

			@Override
			public void controlEvent(CallbackEvent arg0) {
				
				if (false == ADDING_LANDMARKS_MODE) {
					// switch to adding landmarks mode
					ADDING_LANDMARKS_MODE = true;
					//IS_SIM_RUNNING = false;
					landmarksButton.setColorBackground(ActiveGreen);
				}
				else {
					// go back to normal mouse operation
					ADDING_LANDMARKS_MODE = false;
					landmarksButton.setColorBackground(DefaultBlue);
					System.out.println("Landmarks Added");
				}
				
			}
			
		});
		
		/* run button functionality ---------------------------------------------------- */
		runButton.onClick(new CallbackListener () {
			
			@Override
			public void controlEvent(CallbackEvent ev) {
				
				// check particle count
				
				// check sensor noise
				
				// check turn noise
				
				// check forward noise
				
				// check sensor range
				
				/* Use the settings gathered to initialise the program -------------------------- */
				// init a new robot with landmarks
				// init a new random particle distribution
				
				/* set variable indicating that everything has been setup ----------------------- */
				IS_SIM_RUNNING = true;
				
				runButton.setColorBackground(color(0, 204, 102));
				System.out.println("Settings Applied");
			}
		});
	}
	
	
	ControlP5 cp5;
	PFont ArialFont16;
	PFont ArialFont14;
	
	Button landmarksButton;
	
	Button runButton;
	
	
	
	
	
	
	
	
	
	
	
	

	/**
	 * Convert degrees to radians, (short hand wrapper method)
	 * 
	 * @param degrees
	 *            degrees value to convert
	 * @return converted value in radians
	 */
	public double d2r(double degrees) {
		return Math.toRadians(degrees);
	}

}
